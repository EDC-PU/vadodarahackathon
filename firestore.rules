rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions to check user roles and ownership
    function isSignedIn() {
      return request.auth != null;
    }

    function isUser(uid) {
      return isSignedIn() && request.auth.uid == uid;
    }
    
    function getRole(uid) {
        return get(/databases/$(database)/documents/users/$(uid)).data.role;
    }

    function isAdmin() {
      return isSignedIn() && getRole(request.auth.uid) == 'admin';
    }

    function isSpoc() {
        return isSignedIn() && getRole(request.auth.uid) == 'spoc';
    }
    
    function isLeader() {
        return isSignedIn() && getRole(request.auth.uid) == 'leader';
    }
    
    function getUserData(uid) {
        return get(/databases/$(database)/documents/users/$(uid)).data;
    }

    // Users can be created by anyone (during signup)
    // Users can read their own data. Admins can read/write any user.
    // SPOCs can read users from their own institute.
    // Users can update their own data.
    match /users/{userId} {
      allow read: if isSignedIn() && 
                    (isUser(userId) || 
                     isAdmin() || 
                     (isSpoc() && getUserData(request.auth.uid).institute == resource.data.institute));
      allow create: if true;
      allow update: if isSignedIn() && (isUser(userId) || isAdmin() || (isSpoc() && getUserData(request.auth.uid).institute == resource.data.institute));
      allow delete: if isAdmin();
    }
    
    // Teams can be created by leaders (via flow).
    // Read access is granted to team members, the SPOC of the institute, and admins.
    // Write access is granted to the team leader, SPOC of the institute, and admins.
    match /teams/{teamId} {
        function isTeamMember() {
            return isSignedIn() && (
                resource.data.leader.uid == request.auth.uid ||
                request.auth.uid in resource.data.members.map(m => m.uid)
            );
        }
        
        function isTeamSpoc() {
            return isSpoc() && getUserData(request.auth.uid).institute == resource.data.institute;
        }

        allow read: if isSignedIn() && (isTeamMember() || isTeamSpoc() || isAdmin());
        allow create, update: if isSignedIn() && (isLeader() && resource.data.leader.uid == request.auth.uid || isTeamSpoc() || isAdmin());
        allow delete: if isSignedIn() && (isTeamSpoc() || isAdmin());
    }

    // Public team invites can be read by anyone to get team details.
    // They can only be created by leaders (via flow).
    match /teamInvites/{inviteId} {
        allow read: if true;
        allow create: if isLeader();
        allow delete: if isAdmin();
    }
    
    // Notifications are private to the recipient.
    match /notifications/{notificationId} {
        allow read, update, delete: if isSignedIn() && request.auth.uid == resource.data.recipientUid;
        allow create: if isSignedIn(); // Can be created by server-side flows for any user
    }
    
    // Problem statements can be read by any signed-in user.
    // They can only be created/edited/deleted by an admin.
    match /problemStatements/{psId} {
        allow read: if isSignedIn();
        allow create, update, delete: if isAdmin();
    }

    // Public announcements can be read by anyone.
    // Announcements for teams/spocs can be read by signed-in users.
    // Only admins can create/delete announcements.
    match /announcements/{announcementId} {
        allow read: if resource.data.audience == 'all' || isSignedIn();
        allow create, delete: if isAdmin();
    }
    
    // Config can be read by anyone (for registration deadline).
    // Can only be written by admins.
    match /config/{configId} {
      allow read: if true;
      allow write: if isAdmin();
    }
    
    // Health check collection for system status checks.
    // Should only be accessible by the admin backend.
    match /healthchecks/{checkId} {
        allow read, write, delete: if isAdmin();
    }
  }
}
